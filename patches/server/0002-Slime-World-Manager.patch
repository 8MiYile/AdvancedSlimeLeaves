From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Mon, 26 Dec 2022 12:08:05 -0500
Subject: [PATCH] Slime World Manager


diff --git a/build.gradle.kts b/build.gradle.kts
index c6ea826dc1d514adc77d6a4c43a35f07d48e36a8..9fdc9b9c4857e4543b7454b8a1661cc34bd3fb87 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -10,6 +10,8 @@ dependencies {
 
     // ASWM start
     implementation(project(":slimeworldmanager-api"))
+    implementation(project(":api"))
+    implementation(project(":core"))
     implementation("io.papermc.paper:paper-mojangapi:1.19.3-R0.1-SNAPSHOT") {
         exclude("io.papermc.paper", "paper-api")
     }
diff --git a/src/main/java/com/infernalsuite/aswm/ChunkSerialization.java b/src/main/java/com/infernalsuite/aswm/ChunkSerialization.java
new file mode 100644
index 0000000000000000000000000000000000000000..352e386417ad7c4f9feca42f583cfb9abe1701da
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/ChunkSerialization.java
@@ -0,0 +1,8 @@
+package com.infernalsuite.aswm;
+
+import com.flowpowered.nbt.CompoundTag;
+
+import java.util.List;
+
+public record ChunkSerialization(byte[] chunks, List<CompoundTag> tileEntities, List<CompoundTag> entities) {
+}
diff --git a/src/main/java/com/infernalsuite/aswm/Converter.java b/src/main/java/com/infernalsuite/aswm/Converter.java
new file mode 100644
index 0000000000000000000000000000000000000000..14ac753083a3ce8599e5536c06c152bc394c93f2
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/Converter.java
@@ -0,0 +1,119 @@
+package com.infernalsuite.aswm;
+
+import com.flowpowered.nbt.CompoundMap;
+import com.flowpowered.nbt.TagType;
+import com.infernalsuite.aswm.utils.NibbleArray;
+import net.minecraft.nbt.*;
+import net.minecraft.world.level.chunk.DataLayer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class Converter {
+
+    private static final Logger LOGGER = LogManager.getLogger("SWM Converter");
+
+    static DataLayer convertArray(NibbleArray array) {
+        return new DataLayer(array.getBacking());
+    }
+
+    public static NibbleArray convertArray(DataLayer array) {
+        if (array == null) {
+            return null;
+        }
+
+        return new NibbleArray(array.getData());
+    }
+
+    public static Tag convertTag(com.flowpowered.nbt.Tag tag) {
+        try {
+            switch (tag.getType()) {
+                case TAG_BYTE:
+                    return ByteTag.valueOf(((com.flowpowered.nbt.ByteTag) tag).getValue());
+                case TAG_SHORT:
+                    return ShortTag.valueOf(((com.flowpowered.nbt.ShortTag) tag).getValue());
+                case TAG_INT:
+                    return IntTag.valueOf(((com.flowpowered.nbt.IntTag) tag).getValue());
+                case TAG_LONG:
+                    return LongTag.valueOf(((com.flowpowered.nbt.LongTag) tag).getValue());
+                case TAG_FLOAT:
+                    return FloatTag.valueOf(((com.flowpowered.nbt.FloatTag) tag).getValue());
+                case TAG_DOUBLE:
+                    return DoubleTag.valueOf(((com.flowpowered.nbt.DoubleTag) tag).getValue());
+                case TAG_BYTE_ARRAY:
+                    return new ByteArrayTag(((com.flowpowered.nbt.ByteArrayTag) tag).getValue());
+                case TAG_STRING:
+                    return StringTag.valueOf(((com.flowpowered.nbt.StringTag) tag).getValue());
+                case TAG_LIST:
+                    ListTag list = new ListTag();
+                    ((com.flowpowered.nbt.ListTag<?>) tag).getValue().stream().map(Converter::convertTag).forEach(list::add);
+
+                    return list;
+                case TAG_COMPOUND:
+                    CompoundTag compound = new CompoundTag();
+
+                    ((com.flowpowered.nbt.CompoundTag) tag).getValue().forEach((key, value) -> compound.put(key, convertTag(value)));
+                    return compound;
+                case TAG_INT_ARRAY:
+                    return new IntArrayTag(((com.flowpowered.nbt.IntArrayTag) tag).getValue());
+                case TAG_LONG_ARRAY:
+                    return new LongArrayTag(((com.flowpowered.nbt.LongArrayTag) tag).getValue());
+                default:
+                    throw new IllegalArgumentException("Invalid tag type " + tag.getType().name());
+            }
+        } catch (Exception ex) {
+            LOGGER.error("Failed to convert NBT object:");
+            LOGGER.error(tag.toString());
+
+            throw ex;
+        }
+    }
+
+    public static com.flowpowered.nbt.Tag convertTag(String name, Tag base) {
+        switch (base.getId()) {
+            case Tag.TAG_BYTE:
+                return new com.flowpowered.nbt.ByteTag(name, ((ByteTag) base).getAsByte());
+            case Tag.TAG_SHORT:
+                return new com.flowpowered.nbt.ShortTag(name, ((ShortTag) base).getAsShort());
+            case Tag.TAG_INT:
+                return new com.flowpowered.nbt.IntTag(name, ((IntTag) base).getAsInt());
+            case Tag.TAG_LONG:
+                return new com.flowpowered.nbt.LongTag(name, ((LongTag) base).getAsLong());
+            case Tag.TAG_FLOAT:
+                return new com.flowpowered.nbt.FloatTag(name, ((FloatTag) base).getAsFloat());
+            case Tag.TAG_DOUBLE:
+                return new com.flowpowered.nbt.DoubleTag(name, ((DoubleTag) base).getAsDouble());
+            case Tag.TAG_BYTE_ARRAY:
+                return new com.flowpowered.nbt.ByteArrayTag(name, ((ByteArrayTag) base).getAsByteArray());
+            case Tag.TAG_STRING:
+                return new com.flowpowered.nbt.StringTag(name, ((StringTag) base).getAsString());
+            case Tag.TAG_LIST:
+                List<com.flowpowered.nbt.Tag> list = new ArrayList<>();
+                ListTag originalList = ((ListTag) base);
+
+                for (Tag entry : originalList) {
+                    list.add(convertTag("", entry));
+                }
+
+                return new com.flowpowered.nbt.ListTag(name, TagType.getById(originalList.getElementType()), list);
+            case Tag.TAG_COMPOUND:
+                CompoundTag originalCompound = ((CompoundTag) base);
+                com.flowpowered.nbt.CompoundTag compound = new com.flowpowered.nbt.CompoundTag(name, new CompoundMap());
+
+                for (String key : originalCompound.getAllKeys()) {
+                    compound.getValue().put(key, convertTag(key, originalCompound.get(key)));
+                }
+
+                return compound;
+            case Tag.TAG_INT_ARRAY:
+                return new com.flowpowered.nbt.IntArrayTag(name, ((IntArrayTag) base).getAsIntArray());
+            case Tag.TAG_LONG_ARRAY:
+                return new com.flowpowered.nbt.LongArrayTag(name, ((LongArrayTag) base).getAsLongArray());
+            default:
+                throw new IllegalArgumentException("Invalid tag type " + base.getId());
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/com/infernalsuite/aswm/InternalPlugin.java b/src/main/java/com/infernalsuite/aswm/InternalPlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ce7ea15a11abe537edb0aafa8e12e9b6542a885
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/InternalPlugin.java
@@ -0,0 +1,28 @@
+package com.infernalsuite.aswm;
+
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Server;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+import org.bukkit.plugin.PluginLogger;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.logging.LogRecord;
+
+public class InternalPlugin extends MinecraftInternalPlugin {
+
+    @Override
+    public @NotNull Server getServer() {
+        return MinecraftServer.getServer().server;
+    }
+
+    @Override
+    public @NotNull PluginLogger getLogger() {
+        return new PluginLogger(new InternalPlugin()) {
+            @Override
+            public void log(@NotNull LogRecord logRecord) {
+                MinecraftServer.LOGGER.info(logRecord.getMessage());
+            }
+        };
+    }
+
+}
diff --git a/src/main/java/com/infernalsuite/aswm/SimpleDataFixerConverter.java b/src/main/java/com/infernalsuite/aswm/SimpleDataFixerConverter.java
new file mode 100644
index 0000000000000000000000000000000000000000..a73a40a54ad897284cb6a0f8849f255b077172f1
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/SimpleDataFixerConverter.java
@@ -0,0 +1,94 @@
+package com.infernalsuite.aswm;
+
+import ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry;
+import ca.spottedleaf.dataconverter.minecraft.walkers.generic.WalkerUtils;
+import ca.spottedleaf.dataconverter.types.nbt.NBTMapType;
+import com.flowpowered.nbt.CompoundTag;
+import com.infernalsuite.aswm.serialization.SlimeWorldReader;
+import com.infernalsuite.aswm.skeleton.SkeletonSlimeWorld;
+import com.infernalsuite.aswm.skeleton.SlimeChunkSectionSkeleton;
+import com.infernalsuite.aswm.skeleton.SlimeChunkSkeleton;
+import com.infernalsuite.aswm.world.SlimeChunk;
+import com.infernalsuite.aswm.world.SlimeChunkSection;
+import com.infernalsuite.aswm.world.SlimeWorld;
+import net.minecraft.SharedConstants;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Consumer;
+
+class SimpleDataFixerConverter implements SlimeWorldReader<SlimeWorld> {
+
+
+    @Override
+    public SlimeWorld readFromData(SlimeWorld data) {
+        int newVersion = SharedConstants.getCurrentVersion().getWorldVersion();
+        int currentVersion = data.getDataVersion();
+
+        Map<com.infernalsuite.aswm.ChunkPos, SlimeChunk> chunks = new HashMap<>();
+        List<CompoundTag> entities = new ArrayList<>();
+        for (CompoundTag upgradeEntity : data.getEntities()) {
+            entities.add(
+                    convertAndBack(upgradeEntity, (tag) -> MCTypeRegistry.ENTITY.convert(new NBTMapType(tag), currentVersion, newVersion))
+            );
+        }
+
+        for (SlimeChunk chunk : data.getChunkStorage()) {
+            List<CompoundTag> blockEntities = new ArrayList<>();
+            for (CompoundTag upgradeEntity : data.getEntities()) {
+                entities.add(
+                        convertAndBack(upgradeEntity, (tag) -> MCTypeRegistry.TILE_ENTITY.convert(new NBTMapType(tag), currentVersion, newVersion))
+                );
+            }
+
+            SlimeChunkSection[] sections = new SlimeChunkSection[chunk.getSections().length];
+            for (int i = 0; i < sections.length; i++) {
+                SlimeChunkSection dataSection = chunk.getSections()[i];
+
+                com.flowpowered.nbt.CompoundTag blockStateTag = blockStateTag = convertAndBack(dataSection.getBlockStatesTag(), (tag) -> {
+                    WalkerUtils.convertList(MCTypeRegistry.BLOCK_STATE, new NBTMapType(tag), "palette", currentVersion, newVersion);
+                });
+
+                com.flowpowered.nbt.CompoundTag biomeTag = convertAndBack(dataSection.getBiomeTag(), (tag) -> {
+                    WalkerUtils.convertList(MCTypeRegistry.BIOME, new NBTMapType(tag), "palette", currentVersion, newVersion);
+                });
+
+                sections[i] = new SlimeChunkSectionSkeleton(
+                        blockStateTag,
+                        biomeTag,
+                        dataSection.getBlockLight(),
+                        dataSection.getSkyLight()
+                );
+
+                chunks.put(new ChunkPos(chunk.getX(), chunk.getZ()), new SlimeChunkSkeleton(
+                        chunk.getX(),
+                        chunk.getZ(),
+                        sections,
+                        chunk.getHeightMaps(),
+                        blockEntities
+                ));
+            }
+
+        }
+
+        return new SkeletonSlimeWorld(
+                data.getName(),
+                data.getLoader(),
+                chunks,
+                data.getExtraData(),
+                data.getPropertyMap(),
+                entities,
+                newVersion
+        );
+    }
+
+
+    private static com.flowpowered.nbt.CompoundTag convertAndBack(com.flowpowered.nbt.CompoundTag value, Consumer<net.minecraft.nbt.CompoundTag> acceptor) {
+        net.minecraft.nbt.CompoundTag converted = (net.minecraft.nbt.CompoundTag) Converter.convertTag(value);
+        acceptor.accept(converted);
+
+        return (com.flowpowered.nbt.CompoundTag) Converter.convertTag(value.getName(), converted);
+    }
+}
diff --git a/src/main/java/com/infernalsuite/aswm/SlimeNMSBridgeImpl.java b/src/main/java/com/infernalsuite/aswm/SlimeNMSBridgeImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..66442436f172d89f94c11ad41c7d398d93e15bf1
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/SlimeNMSBridgeImpl.java
@@ -0,0 +1,201 @@
+package com.infernalsuite.aswm;
+
+import com.infernalsuite.aswm.world.SlimeWorld;
+import com.infernalsuite.aswm.world.SlimeWorldInstance;
+import com.infernalsuite.aswm.world.properties.SlimeProperties;
+import com.infernalsuite.aswm.level.SlimeBootstrap;
+import com.infernalsuite.aswm.level.SlimeLevelInstance;
+import com.mojang.serialization.Lifecycle;
+import net.kyori.adventure.util.Services;
+import net.minecraft.SharedConstants;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.dedicated.DedicatedServerProperties;
+import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelSettings;
+import net.minecraft.world.level.dimension.LevelStem;
+import net.minecraft.world.level.levelgen.WorldOptions;
+import net.minecraft.world.level.storage.PrimaryLevelData;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.IOException;
+import java.util.Locale;
+
+public class SlimeNMSBridgeImpl implements SlimeNMSBridge {
+
+    private static final SlimeNMSBridgeImpl INSTANCE = (SlimeNMSBridgeImpl) Services.service(SlimeNMSBridge.class).orElseThrow();
+    private static final SimpleDataFixerConverter DATA_FIXER_CONVERTER = new SimpleDataFixerConverter();
+
+    private static final Logger LOGGER = LogManager.getLogger("SWM");
+
+
+
+    public static SlimeNMSBridgeImpl instance() {
+        return INSTANCE;
+    }
+
+
+    private SlimeWorld defaultWorld;
+    private SlimeWorld defaultNetherWorld;
+    private SlimeWorld defaultEndWorld;
+
+    @Override
+    public boolean loadOverworldOverride() {
+        if (defaultWorld == null) {
+            return false;
+        }
+
+        this.loadInstance(defaultWorld, Level.OVERWORLD);
+
+        return true;
+    }
+
+    @Override
+    public boolean loadNetherOverride() {
+        if (defaultNetherWorld == null) {
+            return false;
+        }
+
+        this.loadInstance(defaultNetherWorld, Level.NETHER);
+
+        return true;
+    }
+
+    @Override
+    public boolean loadEndOverride() {
+        if (defaultEndWorld == null) {
+            return false;
+        }
+
+        this.loadInstance(defaultEndWorld, Level.END);
+
+        return true;
+    }
+
+    @Override
+    public void setDefaultWorlds(SlimeWorld normalWorld, SlimeWorld netherWorld, SlimeWorld endWorld) {
+        if (normalWorld != null) {
+            normalWorld.getPropertyMap().setValue(SlimeProperties.ENVIRONMENT, World.Environment.NORMAL.toString().toLowerCase());
+            defaultWorld = normalWorld;
+        }
+
+        if (netherWorld != null) {
+            netherWorld.getPropertyMap().setValue(SlimeProperties.ENVIRONMENT, World.Environment.NETHER.toString().toLowerCase());
+            defaultNetherWorld = netherWorld;
+        }
+
+        if (endWorld != null) {
+            endWorld.getPropertyMap().setValue(SlimeProperties.ENVIRONMENT, World.Environment.THE_END.toString().toLowerCase());
+            defaultEndWorld = endWorld;
+        }
+
+    }
+
+    @Override
+    public SlimeWorldInstance loadInstance(SlimeWorld slimeWorld) {
+        return this.loadInstance(slimeWorld, null);
+    }
+
+    public SlimeWorldInstance loadInstance(SlimeWorld slimeWorld, @Nullable ResourceKey<Level> dimensionOverride) {
+        String worldName = slimeWorld.getName();
+
+        if (Bukkit.getWorld(worldName) != null) {
+            throw new IllegalArgumentException("World " + worldName + " already exists! Maybe it's an outdated SlimeWorld object?");
+        }
+
+        SlimeLevelInstance server = createCustomWorld(slimeWorld, dimensionOverride);
+        registerWorld(server);
+        return server.getSlimeInstance();
+    }
+
+    @Override
+    public SlimeWorldInstance getInstance(World world) {
+        CraftWorld craftWorld = (CraftWorld) world;
+
+        if (!(craftWorld.getHandle() instanceof SlimeLevelInstance worldServer)) {
+            return null;
+        }
+
+        return worldServer.getSlimeInstance();
+    }
+
+    @Override
+    public SlimeWorld applyDataFixers(SlimeWorld world) {
+        return DATA_FIXER_CONVERTER.readFromData(world);
+    }
+
+
+    @Override
+    public int getCurrentVersion() {
+        return SharedConstants.getCurrentVersion().getWorldVersion();
+    }
+
+    public void registerWorld(SlimeLevelInstance server) {
+        MinecraftServer mcServer = MinecraftServer.getServer();
+        mcServer.initWorld(server, server.serverLevelData, mcServer.getWorldData(), server.serverLevelData.worldGenOptions());
+
+        mcServer.addLevel(server);
+    }
+
+    private SlimeLevelInstance createCustomWorld(SlimeWorld world, @Nullable ResourceKey<Level> dimensionOverride) {
+        SlimeBootstrap bootstrap = new SlimeBootstrap(world);
+        String worldName = world.getName();
+
+        PrimaryLevelData worldDataServer = createWorldData(world);
+        World.Environment environment = getEnvironment(world);
+        ResourceKey<LevelStem> dimension = switch (environment) {
+            case NORMAL -> LevelStem.OVERWORLD;
+            case NETHER -> LevelStem.NETHER;
+            case THE_END -> LevelStem.END;
+            default -> throw new IllegalArgumentException("Unknown dimension supplied");
+        };
+
+        ResourceKey<Level> worldKey = dimensionOverride == null ? ResourceKey.create(Registries.DIMENSION, new ResourceLocation(worldName.toLowerCase(Locale.ENGLISH))) : dimensionOverride;
+        LevelStem stem = MinecraftServer.getServer().registries().compositeAccess().registryOrThrow(Registries.LEVEL_STEM).get(dimension);
+
+        SlimeLevelInstance level;
+
+        try {
+            level = new SlimeLevelInstance(bootstrap, worldDataServer, worldKey, dimension, stem, environment);
+        } catch (IOException ex) {
+            throw new RuntimeException(ex); // TODO do something better with this?
+        }
+
+        // level.setReady(true);
+        level.setSpawnSettings(world.getPropertyMap().getValue(SlimeProperties.ALLOW_MONSTERS), world.getPropertyMap().getValue(SlimeProperties.ALLOW_ANIMALS));
+
+        return level;
+    }
+
+    private World.Environment getEnvironment(SlimeWorld world) {
+        return World.Environment.valueOf(world.getPropertyMap().getValue(SlimeProperties.ENVIRONMENT).toUpperCase());
+    }
+
+    private PrimaryLevelData createWorldData(SlimeWorld world) {
+        MinecraftServer mcServer = MinecraftServer.getServer();
+        DedicatedServerProperties serverProps = ((DedicatedServer) mcServer).getProperties();
+        String worldName = world.getName();
+
+        LevelSettings worldsettings = new LevelSettings(worldName, serverProps.gamemode, false, serverProps.difficulty,
+                true, new GameRules(), mcServer.worldLoader.dataConfiguration());
+
+        WorldOptions worldoptions = new WorldOptions(0, false, false);
+
+        PrimaryLevelData data = new PrimaryLevelData(worldsettings, worldoptions, PrimaryLevelData.SpecialWorldProperty.FLAT, Lifecycle.stable());
+        data.checkName(worldName);
+        data.setModdedInfo(mcServer.getServerModName(), mcServer.getModdedStatus().shouldReportAsModified());
+        data.setInitialized(true);
+
+        return data;
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/com/infernalsuite/aswm/level/NMSSlimeChunk.java b/src/main/java/com/infernalsuite/aswm/level/NMSSlimeChunk.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f4d1ca18cb16e186d46c7e697a9eb15f72ea80a
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/level/NMSSlimeChunk.java
@@ -0,0 +1,126 @@
+package com.infernalsuite.aswm.level;
+
+import com.flowpowered.nbt.CompoundMap;
+import com.flowpowered.nbt.CompoundTag;
+import com.flowpowered.nbt.LongArrayTag;
+import com.infernalsuite.aswm.utils.NibbleArray;
+import com.infernalsuite.aswm.world.SlimeChunk;
+import com.infernalsuite.aswm.world.SlimeChunkSection;
+import com.infernalsuite.aswm.Converter;
+import com.infernalsuite.aswm.skeleton.SlimeChunkSectionSkeleton;
+import com.mojang.serialization.Codec;
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.core.SectionPos;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.nbt.NbtOps;
+import net.minecraft.nbt.Tag;
+import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LevelChunkSection;
+import net.minecraft.world.level.chunk.PalettedContainer;
+import net.minecraft.world.level.chunk.PalettedContainerRO;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import net.minecraft.world.level.levelgen.Heightmap;
+import net.minecraft.world.level.lighting.LevelLightEngine;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+public class NMSSlimeChunk implements SlimeChunk {
+
+    private LevelChunk chunk;
+
+    public NMSSlimeChunk(LevelChunk chunk) {
+        this.chunk = chunk;
+    }
+
+    @Override
+    public int getX() {
+        return chunk.getPos().x;
+    }
+
+    @Override
+    public int getZ() {
+        return chunk.getPos().z;
+    }
+
+    @Override
+    public SlimeChunkSection[] getSections() {
+        SlimeChunkSection[] sections = new SlimeChunkSection[this.chunk.getMaxSection() - this.chunk.getMinSection() + 1];
+        LevelLightEngine lightEngine = chunk.getLevel().getChunkSource().getLightEngine();
+
+        Registry<Biome> biomeRegistry = chunk.getLevel().registryAccess().registryOrThrow(Registries.BIOME);
+
+        // Ignore deprecation, spigot only method
+        Codec<PalettedContainerRO<Holder<Biome>>> codec = PalettedContainer.codecRO(biomeRegistry.asHolderIdMap(), biomeRegistry.holderByNameCodec(), PalettedContainer.Strategy.SECTION_BIOMES, biomeRegistry.getHolderOrThrow(Biomes.PLAINS));
+
+        for (int sectionId = 0; sectionId < chunk.getSections().length; sectionId++) {
+            LevelChunkSection section = chunk.getSections()[sectionId];
+            // Sections CANNOT be null in 1.18
+
+            // Block Light Nibble Array
+            NibbleArray blockLightArray = Converter.convertArray(lightEngine.getLayerListener(LightLayer.BLOCK).getDataLayerData(SectionPos.of(chunk.getPos(), sectionId)));
+
+            // Sky light Nibble Array
+            NibbleArray skyLightArray = Converter.convertArray(lightEngine.getLayerListener(LightLayer.SKY).getDataLayerData(SectionPos.of(chunk.getPos(), sectionId)));
+
+            // Tile/Entity Data
+
+            // Block Data
+            Tag blockStateData = ChunkSerializer.BLOCK_STATE_CODEC.encodeStart(NbtOps.INSTANCE, section.getStates()).getOrThrow(false, System.err::println); // todo error handling
+            Tag biomeData = codec.encodeStart(NbtOps.INSTANCE, section.getBiomes()).getOrThrow(false, System.err::println); // todo error handling
+
+            CompoundTag blockStateTag = (CompoundTag) Converter.convertTag("", blockStateData);
+            CompoundTag biomeTag = (CompoundTag) Converter.convertTag("", biomeData);
+
+            sections[sectionId] = new SlimeChunkSectionSkeleton(blockStateTag, biomeTag, blockLightArray, skyLightArray);
+        }
+
+        return sections;
+    }
+
+    @Override
+    public CompoundTag getHeightMaps() {
+        // HeightMap
+        CompoundMap heightMaps = new CompoundMap();
+
+        for (Map.Entry<Heightmap.Types, Heightmap> entry : chunk.heightmaps.entrySet()) {
+            if (!entry.getKey().keepAfterWorldgen()) {
+                continue;
+            }
+
+            Heightmap.Types type = entry.getKey();
+            Heightmap map = entry.getValue();
+
+            heightMaps.put(type.name(), new LongArrayTag(type.name(), map.getRawData()));
+        }
+
+        return new CompoundTag("", heightMaps);
+    }
+
+    @Override
+    public List<CompoundTag> getTileEntities() {
+        List<CompoundTag> tileEntities = new ArrayList<>();
+
+        for (BlockEntity entity : chunk.blockEntities.values()) {
+            net.minecraft.nbt.CompoundTag entityNbt = entity.saveWithFullMetadata();
+            tileEntities.add((CompoundTag) Converter.convertTag(entityNbt.getString("id"), entityNbt));
+        }
+
+        return tileEntities;
+    }
+
+    public LevelChunk getChunk() {
+        return chunk;
+    }
+
+    public void setChunk(LevelChunk chunk) {
+        this.chunk = chunk;
+    }
+
+}
diff --git a/src/main/java/com/infernalsuite/aswm/level/NMSSlimeWorld.java b/src/main/java/com/infernalsuite/aswm/level/NMSSlimeWorld.java
new file mode 100644
index 0000000000000000000000000000000000000000..c15ad49cbe11ddd7ca307f39452199b54d1eeeea
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/level/NMSSlimeWorld.java
@@ -0,0 +1,106 @@
+package com.infernalsuite.aswm.level;
+
+import com.flowpowered.nbt.CompoundTag;
+import com.infernalsuite.aswm.exceptions.WorldAlreadyExistsException;
+import com.infernalsuite.aswm.loaders.SlimeLoader;
+import com.infernalsuite.aswm.world.SlimeChunk;
+import com.infernalsuite.aswm.world.SlimeWorld;
+import com.infernalsuite.aswm.world.properties.SlimePropertyMap;
+import com.infernalsuite.aswm.Converter;
+import net.minecraft.SharedConstants;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.chunk.LevelChunk;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Collectors;
+
+public class NMSSlimeWorld implements SlimeWorld {
+
+    private final SlimeLevelInstance instance;
+
+    public NMSSlimeWorld(SlimeLevelInstance instance) {
+        this.instance = instance;
+    }
+
+    @Override
+    public String getName() {
+        return this.instance.getMinecraftWorld().serverLevelData.getLevelName();
+    }
+
+    @Override
+    public SlimeLoader getLoader() {
+        return this.instance.slimeInstance.getSaveStrategy();
+    }
+
+    @Override
+    public SlimeChunk getChunk(int x, int z) {
+        LevelChunk chunk = this.instance.getChunkIfLoaded(x, z);
+        if (chunk == null) {
+            return null;
+        }
+
+        return new NMSSlimeChunk(chunk);
+    }
+
+    @Override
+    public Collection<SlimeChunk> getChunkStorage() {
+        List<ChunkHolder> chunks = io.papermc.paper.chunk.system.ChunkSystem.getVisibleChunkHolders(this.instance); // Paper
+        return chunks.stream().map(ChunkHolder::getFullChunkNow).filter(Objects::nonNull)
+                .map(NMSSlimeChunk::new)
+                .collect(Collectors.toList());
+    }
+
+    @Override
+    public CompoundTag getExtraData() {
+        return this.instance.slimeInstance.getExtraData();
+    }
+
+    @Override
+    public Collection<CompoundTag> getWorldMaps() {
+        return List.of();
+    }
+
+    @Override
+    public SlimePropertyMap getPropertyMap() {
+        return this.instance.slimeInstance.getPropertyMap();
+    }
+
+    @Override
+    public boolean isReadOnly() {
+        return this.getLoader() == null;
+    }
+
+    @Override
+    public SlimeWorld clone(String worldName) {
+        return null;
+    }
+
+    @Override
+    public SlimeWorld clone(String worldName, SlimeLoader loader) throws WorldAlreadyExistsException, IOException {
+        return null;
+    }
+
+    @Override
+    public int getDataVersion() {
+        return SharedConstants.getCurrentVersion().getWorldVersion();
+    }
+
+    @Override
+    public List<CompoundTag> getEntities() {
+        List<CompoundTag> entities = new ArrayList<>();
+
+        for (Entity entity : this.instance.getEntities().getAll()) {
+            net.minecraft.nbt.CompoundTag entityNbt = new net.minecraft.nbt.CompoundTag();
+            if (entity.save(entityNbt)) {
+                entities.add((CompoundTag) Converter.convertTag("", entityNbt));
+            }
+        }
+
+        return entities;
+    }
+}
diff --git a/src/main/java/com/infernalsuite/aswm/level/SlimeBootstrap.java b/src/main/java/com/infernalsuite/aswm/level/SlimeBootstrap.java
new file mode 100644
index 0000000000000000000000000000000000000000..1dfa3d5d5d59e8dbf2e0cffd47c4136a510a4400
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/level/SlimeBootstrap.java
@@ -0,0 +1,9 @@
+package com.infernalsuite.aswm.level;
+
+import com.infernalsuite.aswm.loaders.SlimeLoader;
+import com.infernalsuite.aswm.world.SlimeWorld;
+
+public record SlimeBootstrap(
+        SlimeWorld initial
+) {
+}
diff --git a/src/main/java/com/infernalsuite/aswm/level/SlimeChunkConverter.java b/src/main/java/com/infernalsuite/aswm/level/SlimeChunkConverter.java
new file mode 100644
index 0000000000000000000000000000000000000000..d75963c2e68b1f1bfd04d57e196dc292fee9a8ae
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/level/SlimeChunkConverter.java
@@ -0,0 +1,164 @@
+package com.infernalsuite.aswm.level;
+
+import ca.spottedleaf.starlight.common.light.SWMRNibbleArray;
+import com.flowpowered.nbt.CompoundMap;
+import com.flowpowered.nbt.LongArrayTag;
+import com.infernalsuite.aswm.utils.NibbleArray;
+import com.infernalsuite.aswm.world.SlimeChunk;
+import com.infernalsuite.aswm.world.SlimeChunkSection;
+import com.infernalsuite.aswm.Converter;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.nbt.NbtOps;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LevelChunkSection;
+import net.minecraft.world.level.chunk.PalettedContainer;
+import net.minecraft.world.level.chunk.UpgradeData;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import net.minecraft.world.level.levelgen.Heightmap;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.ticks.LevelChunkTicks;
+
+import java.util.EnumSet;
+
+public class SlimeChunkConverter {
+
+    static LevelChunk deserializeSlimeChunk(SlimeLevelInstance instance, SlimeChunk chunk) {
+        int x = chunk.getX();
+        int z = chunk.getZ();
+
+        ChunkPos pos = new ChunkPos(x, z);
+
+        // Chunk sections
+        LevelChunkSection[] sections = new LevelChunkSection[instance.getSectionsCount()];
+
+        SWMRNibbleArray[] blockNibbles = ca.spottedleaf.starlight.common.light.StarLightEngine.getFilledEmptyLight(instance);
+        SWMRNibbleArray[] skyNibbles = ca.spottedleaf.starlight.common.light.StarLightEngine.getFilledEmptyLight(instance);
+        instance.getServer().scheduleOnMain(() -> {
+            instance.getLightEngine().retainData(pos, true);
+        });
+
+        Registry<Biome> biomeRegistry = instance.registryAccess().registryOrThrow(Registries.BIOME);
+        // Ignore deprecated method
+
+        Codec<PalettedContainer<Holder<Biome>>> codec = PalettedContainer.codecRW(biomeRegistry.asHolderIdMap(), biomeRegistry.holderByNameCodec(), PalettedContainer.Strategy.SECTION_BIOMES, biomeRegistry.getHolderOrThrow(Biomes.PLAINS), null);
+
+        for (int sectionId = 0; sectionId < chunk.getSections().length; sectionId++) {
+            SlimeChunkSection slimeSection = chunk.getSections()[sectionId];
+
+            if (slimeSection != null) {
+                BlockState[] presetBlockStates = null;
+                NibbleArray blockLight = slimeSection.getBlockLight();
+                if (blockLight != null) {
+                    blockNibbles[sectionId] = new SWMRNibbleArray(blockLight.getBacking());
+                }
+
+                NibbleArray skyLight = slimeSection.getSkyLight();
+                if (skyLight != null) {
+                    skyNibbles[sectionId] = new SWMRNibbleArray(skyLight.getBacking());
+                }
+
+                presetBlockStates = instance.chunkPacketBlockController.getPresetBlockStates(instance, pos, sectionId << 4); // todo this is for anti xray.. do we need it?
+
+                PalettedContainer<BlockState> blockPalette;
+                if (slimeSection.getBlockStatesTag() != null) {
+                    Codec<PalettedContainer<BlockState>> blockStateCodec = presetBlockStates == null ? ChunkSerializer.BLOCK_STATE_CODEC : PalettedContainer.codecRW(Block.BLOCK_STATE_REGISTRY, BlockState.CODEC, PalettedContainer.Strategy.SECTION_STATES, Blocks.AIR.defaultBlockState(), presetBlockStates);
+                    DataResult<PalettedContainer<BlockState>> dataresult = blockStateCodec.parse(NbtOps.INSTANCE, Converter.convertTag(slimeSection.getBlockStatesTag())).promotePartial((s) -> {
+                        System.out.println("Recoverable error when parsing section " + x + "," + z + ": " + s); // todo proper logging
+                    });
+                    blockPalette = dataresult.getOrThrow(false, System.err::println); // todo proper logging
+                } else {
+                    blockPalette = new PalettedContainer<>(Block.BLOCK_STATE_REGISTRY, Blocks.AIR.defaultBlockState(), PalettedContainer.Strategy.SECTION_STATES, presetBlockStates);
+                }
+
+                PalettedContainer<Holder<Biome>> biomePalette;
+
+                if (slimeSection.getBiomeTag() != null) {
+                    DataResult<PalettedContainer<Holder<Biome>>> dataresult = codec.parse(NbtOps.INSTANCE, Converter.convertTag(slimeSection.getBiomeTag())).promotePartial((s) -> {
+                        System.out.println("Recoverable error when parsing section " + x + "," + z + ": " + s); // todo proper logging
+                    });
+                    biomePalette = dataresult.getOrThrow(false, System.err::println); // todo proper logging
+                } else {
+                    biomePalette = new PalettedContainer<>(biomeRegistry.asHolderIdMap(), biomeRegistry.getHolderOrThrow(Biomes.PLAINS), PalettedContainer.Strategy.SECTION_BIOMES);
+                }
+
+                if (sectionId < sections.length) {
+                    LevelChunkSection section = new LevelChunkSection(sectionId << 4, blockPalette, biomePalette);
+                    sections[sectionId] = section;
+                }
+            }
+        }
+
+        // Keep the chunk loaded at level 33 to avoid light glitches
+        // Such a high level will let the server not tick the chunk,
+        // but at the same time it won't be completely unloaded from memory
+//        getChunkProvider().addTicket(SWM_TICKET, pos, 33, Unit.INSTANCE);
+
+
+        LevelChunk.PostLoadProcessor loadEntities = (nmsChunk) -> {
+
+            // TODO
+            // Load tile entities
+//            System.out.println("Loading tile entities for chunk (" + pos.x + ", " + pos.z + ") on world " + slimeWorld.getName());
+//            List<CompoundTag> tileEntities = chunk.getTileEntities();
+//
+//            if (tileEntities != null) {
+//                for (CompoundTag tag : tileEntities) {
+//                    Optional<String> type = tag.getStringValue("id");
+//
+//                    // Sometimes null tile entities are saved
+//                    if (type.isPresent()) {
+//                        BlockPos blockPosition = new BlockPos(tag.getIntValue("x").get(), tag.getIntValue("y").get(), tag.getIntValue("z").get());
+//                        BlockState blockData = nmsChunk.getBlockState(blockPosition);
+//                        BlockEntity entity = BlockEntity.loadStatic(blockPosition, blockData, (net.minecraft.nbt.CompoundTag) Converter.convertTag(tag));
+//
+//                        if (entity != null) {
+//                            nmsChunk.setBlockEntity(entity);
+//                        }
+//                    }
+//                }
+//            }
+        };
+
+        LevelChunkTicks<Block> blockLevelChunkTicks = new LevelChunkTicks<>();
+        LevelChunkTicks<Fluid> fluidLevelChunkTicks = new LevelChunkTicks<>();
+        LevelChunk nmsChunk = new LevelChunk(instance, pos, UpgradeData.EMPTY, blockLevelChunkTicks, fluidLevelChunkTicks, 0L, sections, loadEntities, null);
+
+        // Height Maps
+        EnumSet<Heightmap.Types> heightMapTypes = nmsChunk.getStatus().heightmapsAfter();
+        CompoundMap heightMaps = chunk.getHeightMaps().getValue();
+        EnumSet<Heightmap.Types> unsetHeightMaps = EnumSet.noneOf(Heightmap.Types.class);
+
+        // Light
+        nmsChunk.setBlockNibbles(blockNibbles);
+        nmsChunk.setSkyNibbles(skyNibbles);
+
+        for (Heightmap.Types type : heightMapTypes) {
+            String name = type.getSerializedName();
+
+            if (heightMaps.containsKey(name)) {
+                LongArrayTag heightMap = (LongArrayTag) heightMaps.get(name);
+                nmsChunk.setHeightmap(type, heightMap.getValue());
+            } else {
+                unsetHeightMaps.add(type);
+            }
+        }
+
+        // Don't try to populate heightmaps if there are none.
+        // Does a crazy amount of block lookups
+        if (!unsetHeightMaps.isEmpty()) {
+            Heightmap.primeHeightmaps(nmsChunk, unsetHeightMaps);
+        }
+
+        return nmsChunk;
+    }
+}
diff --git a/src/main/java/com/infernalsuite/aswm/level/SlimeLevelGenerator.java b/src/main/java/com/infernalsuite/aswm/level/SlimeLevelGenerator.java
new file mode 100644
index 0000000000000000000000000000000000000000..34f8866dfb6a5b88e8343dda3aac42bc7d7d1ae8
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/level/SlimeLevelGenerator.java
@@ -0,0 +1,34 @@
+package com.infernalsuite.aswm.level;
+
+import com.mojang.serialization.Codec;
+import net.minecraft.core.Holder;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.biome.BiomeSource;
+import net.minecraft.world.level.biome.Climate;
+import net.minecraft.world.level.levelgen.FlatLevelSource;
+import net.minecraft.world.level.levelgen.flat.FlatLevelGeneratorSettings;
+
+import java.util.List;
+import java.util.Optional;
+
+public class SlimeLevelGenerator extends FlatLevelSource {
+
+    public SlimeLevelGenerator(Holder<Biome> biome) {
+        super(new FlatLevelGeneratorSettings(Optional.empty(), biome, List.of()), getSource(biome));
+    }
+
+
+    private static BiomeSource getSource(Holder<Biome> biome) {
+        return new BiomeSource(List.of(biome)) {
+            @Override
+            protected Codec<? extends BiomeSource> codec() {
+                return null;
+            }
+
+            @Override
+            public Holder<Biome> getNoiseBiome(int x, int y, int z, Climate.Sampler noise) {
+                return biome;
+            }
+        };
+    }
+}
diff --git a/src/main/java/com/infernalsuite/aswm/level/SlimeLevelInstance.java b/src/main/java/com/infernalsuite/aswm/level/SlimeLevelInstance.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5cce1672048cb6eac67d4265045ee1f88dc2fd2
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/level/SlimeLevelInstance.java
@@ -0,0 +1,141 @@
+package com.infernalsuite.aswm.level;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import com.infernalsuite.aswm.world.SlimeWorldInstance;
+import com.infernalsuite.aswm.world.properties.SlimeProperties;
+import com.infernalsuite.aswm.world.properties.SlimePropertyMap;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.TicketType;
+import net.minecraft.util.ProgressListener;
+import net.minecraft.util.Unit;
+import net.minecraft.util.datafix.DataFixers;
+import net.minecraft.world.Difficulty;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.dimension.LevelStem;
+import net.minecraft.world.level.storage.LevelStorageSource;
+import net.minecraft.world.level.storage.PrimaryLevelData;
+import org.apache.commons.io.FileUtils;
+import org.bukkit.Bukkit;
+import org.bukkit.event.world.WorldSaveEvent;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Collections;
+import java.util.UUID;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.logging.Level;
+
+public class SlimeLevelInstance extends ServerLevel {
+
+
+    public static LevelStorageSource CUSTOM_LEVEL_STORAGE;
+
+    static {
+        try {
+            Path path = Files.createTempDirectory("swm-" + UUID.randomUUID().toString().substring(0, 5)).toAbsolutePath();
+            CUSTOM_LEVEL_STORAGE = new LevelStorageSource(path, path, DataFixers.getDataFixer());
+
+            FileUtils.forceDeleteOnExit(path.toFile());
+
+        } catch (IOException ex) {
+            throw new IllegalStateException("Couldn't create dummy file directory.", ex);
+        }
+    }
+
+    private static final ExecutorService WORLD_SAVER_SERVICE = Executors.newFixedThreadPool(4, new ThreadFactoryBuilder()
+            .setNameFormat("SWM Pool Thread #%1$d").build());
+    private static final TicketType<Unit> SWM_TICKET = TicketType.create("swm-chunk", (a, b) -> 0);
+
+    private final Object saveLock = new Object();
+
+    private boolean ready = false;
+
+    public SlimeLevelInstance(SlimeBootstrap slimeBootstrap, PrimaryLevelData primaryLevelData,
+                              ResourceKey<net.minecraft.world.level.Level> worldKey,
+                              ResourceKey<LevelStem> dimensionKey, LevelStem worldDimension,
+                              org.bukkit.World.Environment environment) throws IOException {
+
+        super(slimeBootstrap, MinecraftServer.getServer(), MinecraftServer.getServer().executor,
+                CUSTOM_LEVEL_STORAGE.createAccess(slimeBootstrap.initial().getName() + UUID.randomUUID(), dimensionKey),
+                primaryLevelData, worldKey, worldDimension,
+                MinecraftServer.getServer().progressListenerFactory.create(11), false, 0,
+                Collections.emptyList(), true, environment, null, null);
+        this.slimeInstance = new v1192SlimeLoadedWorld(slimeBootstrap, this);
+
+
+        SlimePropertyMap propertyMap = slimeBootstrap.initial().getPropertyMap();
+
+        this.serverLevelData.setDifficulty(Difficulty.valueOf(propertyMap.getValue(SlimeProperties.DIFFICULTY).toUpperCase()));
+        this.serverLevelData.setSpawn(new BlockPos(propertyMap.getValue(SlimeProperties.SPAWN_X), propertyMap.getValue(SlimeProperties.SPAWN_Y), propertyMap.getValue(SlimeProperties.SPAWN_Z)), 0);
+        super.setSpawnSettings(propertyMap.getValue(SlimeProperties.ALLOW_MONSTERS), propertyMap.getValue(SlimeProperties.ALLOW_ANIMALS));
+
+        this.pvpMode = propertyMap.getValue(SlimeProperties.PVP);
+
+        this.keepSpawnInMemory = false;
+    }
+
+    @Override
+    public ChunkGenerator getGenerator() {
+        String biomeStr = this.slimeInstance.getPropertyMap().getValue(SlimeProperties.DEFAULT_BIOME);
+        ResourceKey<Biome> biomeKey = ResourceKey.create(Registries.BIOME, new ResourceLocation(biomeStr));
+        Holder<Biome> defaultBiome = MinecraftServer.getServer().registryAccess().registryOrThrow(Registries.BIOME).getHolder(biomeKey).orElseThrow();
+        return new SlimeLevelGenerator(defaultBiome);
+    }
+
+    @Override
+    public void save(@Nullable ProgressListener progressUpdate, boolean forceSave, boolean savingDisabled) {
+        if (!this.slimeInstance.isReadOnly() && !savingDisabled) {
+            Bukkit.getPluginManager().callEvent(new WorldSaveEvent(getWorld()));
+
+            //this.getChunkSource().save(forceSave);
+            this.serverLevelData.setWorldBorder(this.getWorldBorder().createSettings());
+            this.serverLevelData.setCustomBossEvents(MinecraftServer.getServer().getCustomBossEvents().save());
+
+            // Update level data
+            net.minecraft.nbt.CompoundTag compound = new net.minecraft.nbt.CompoundTag();
+            net.minecraft.nbt.CompoundTag nbtTagCompound = this.serverLevelData.createTag(MinecraftServer.getServer().registryAccess(), compound);
+
+            if (MinecraftServer.getServer().isStopped()) { // Make sure the world gets saved before stopping the server by running it from the main thread
+                save();
+            } else {
+                WORLD_SAVER_SERVICE.execute(this::save);
+            }
+        }
+    }
+
+    // This may not work with spigot.
+    @Override
+    public void save(@Nullable ProgressListener progressListener, boolean flush, boolean savingDisabled, boolean close) {
+        this.save(progressListener, flush, savingDisabled);
+    }
+
+    private void save() {
+        synchronized (saveLock) { // Don't want to save the SlimeWorld from multiple threads simultaneously
+            try {
+                SlimeWorldInstance slimeWorld = this.slimeInstance;
+                Bukkit.getLogger().log(Level.INFO, "Saving world " + this.slimeInstance.getName() + "...");
+                long start = System.currentTimeMillis();
+                byte[] serializedWorld = slimeWorld.serialize().join();
+                long saveStart = System.currentTimeMillis();
+                slimeWorld.getSaveStrategy().saveWorld(slimeWorld.getName(), serializedWorld, false);
+                Bukkit.getLogger().log(Level.INFO, "World " + slimeWorld.getName() + " serialized in " + (saveStart - start) + "ms and saved in " + (System.currentTimeMillis() - saveStart) + "ms.");
+            } catch (IOException | IllegalStateException ex) {
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    public SlimeWorldInstance getSlimeInstance() {
+        return this.slimeInstance;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/infernalsuite/aswm/level/v1192SlimeLoadedWorld.java b/src/main/java/com/infernalsuite/aswm/level/v1192SlimeLoadedWorld.java
new file mode 100644
index 0000000000000000000000000000000000000000..faea20787ad99c06713c82967f81c59a63d7d8a7
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/level/v1192SlimeLoadedWorld.java
@@ -0,0 +1,73 @@
+package com.infernalsuite.aswm.level;
+
+import com.flowpowered.nbt.CompoundTag;
+import com.infernalsuite.aswm.loaders.SlimeLoader;
+import com.infernalsuite.aswm.world.SlimeWorld;
+import com.infernalsuite.aswm.world.SlimeWorldInstance;
+import com.infernalsuite.aswm.world.properties.SlimePropertyMap;
+import com.infernalsuite.aswm.serialization.slime.SlimeSerializer;
+import org.bukkit.World;
+
+import java.util.concurrent.CompletableFuture;
+
+public class v1192SlimeLoadedWorld implements SlimeWorldInstance {
+
+
+    private final SlimeLevelInstance instance;
+    private final SlimeWorld world;
+
+    private final CompoundTag extra;
+    private final SlimePropertyMap propertyMap;
+    private final SlimeLoader loader;
+
+
+    public v1192SlimeLoadedWorld(SlimeBootstrap bootstrap, SlimeLevelInstance instance) {
+        this.instance = instance;
+        this.extra = bootstrap.initial().getExtraData();
+        this.propertyMap = bootstrap.initial().getPropertyMap();
+        this.loader = bootstrap.initial().getLoader();
+
+        this.world = new NMSSlimeWorld(instance);
+    }
+
+
+    @Override
+    public String getName() {
+        return this.instance.getMinecraftWorld().serverLevelData.getLevelName();
+    }
+
+    @Override
+    public World getBukkitWorld() {
+        return this.instance.getWorld();
+    }
+
+    @Override
+    public SlimeWorld getSlimeWorldMirror() {
+        return this.world;
+    }
+
+    @Override
+    public SlimePropertyMap getPropertyMap() {
+        return this.propertyMap;
+    }
+
+    @Override
+    public boolean isReadOnly() {
+        return this.getSaveStrategy() == null;
+    }
+
+    @Override
+    public SlimeLoader getSaveStrategy() {
+        return this.loader;
+    }
+
+    @Override
+    public CompletableFuture<byte[]> serialize() {
+        return CompletableFuture.completedFuture(SlimeSerializer.serialize(this.world));
+    }
+
+    @Override
+    public CompoundTag getExtraData() {
+        return this.extra;
+    }
+}
diff --git a/src/main/java/com/infernalsuite/aswm/util/NmsUtil.java b/src/main/java/com/infernalsuite/aswm/util/NmsUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..b3dc43c74010bb694b82f5f857cb556f819200d7
--- /dev/null
+++ b/src/main/java/com/infernalsuite/aswm/util/NmsUtil.java
@@ -0,0 +1,9 @@
+package com.infernalsuite.aswm.util;
+
+public class NmsUtil {
+
+    public static long asLong(int chunkX, int chunkZ) {
+        return (((long) chunkZ) * Integer.MAX_VALUE + ((long) chunkX));
+        //return (long)chunkX & 4294967295L | ((long)chunkZ & 4294967295L) << 32;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index b66dace70c6f94d9e246c802726751c4ec794420..cc7d5bc390bbf37ca425c9b5d267fad3a6672f0e 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -461,18 +461,33 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             if (dimensionKey == LevelStem.NETHER) {
                 if (this.isNetherEnabled()) {
                     dimension = -1;
+                    // ASWM START
+                    if (com.infernalsuite.aswm.SlimeNMSBridgeImpl.instance().loadOverworldOverride()) {
+                        continue;
+                    }
+                    // ASWM END
                 } else {
                     continue;
                 }
             } else if (dimensionKey == LevelStem.END) {
                 if (this.server.getAllowEnd()) {
                     dimension = 1;
+                    // ASWM START
+                    if (com.infernalsuite.aswm.SlimeNMSBridgeImpl.instance().loadEndOverride()) {
+                        continue;
+                    }
+                    // ASWM END
                 } else {
                     continue;
                 }
             } else if (dimensionKey != LevelStem.OVERWORLD) {
                 dimension = -999;
             }
+            // ASWM START
+            else if (dimensionKey == LevelStem.OVERWORLD && com.infernalsuite.aswm.SlimeNMSBridgeImpl.instance().loadOverworldOverride()) {
+                continue;
+            }
+            // ASWM END
 
             String worldType = (dimension == -999) ? dimensionKey.location().getNamespace() + "_" + dimensionKey.location().getPath() : org.bukkit.World.Environment.getEnvironment(dimension).toString().toLowerCase();
             String name = (dimensionKey == LevelStem.OVERWORLD) ? s : s + "_" + worldType;
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index f3a19d00f78e19aa98c57461efb90d79f656a992..2e8311db4f5e2ae53a98e9f0c1193da11ed06cc8 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -128,12 +128,10 @@ import net.minecraft.world.level.chunk.storage.EntityStorage;
 import net.minecraft.world.level.dimension.BuiltinDimensionTypes;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.dimension.end.EndDragonFight;
-import net.minecraft.world.level.entity.EntityPersistentStorage;
 import net.minecraft.world.level.entity.EntityTickList;
 import net.minecraft.world.level.entity.EntityTypeTest;
 import net.minecraft.world.level.entity.LevelCallback;
 import net.minecraft.world.level.entity.LevelEntityGetter;
-import net.minecraft.world.level.entity.PersistentEntitySectionManager;
 import net.minecraft.world.level.gameevent.DynamicGameEventListener;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.gameevent.GameEventDispatcher;
@@ -160,16 +158,13 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.ticks.LevelTicks;
 import org.slf4j.Logger;
 import org.bukkit.Bukkit;
-import org.bukkit.Location;
 import org.bukkit.WeatherType;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.generator.CustomWorldChunkManager;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.craftbukkit.util.WorldUUID;
 import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
-import org.bukkit.event.world.GenericGameEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
@@ -527,6 +522,14 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     // Add env and gen to constructor, IWorldDataServer -> WorldDataServer
     public ServerLevel(MinecraftServer minecraftserver, Executor executor, LevelStorageSource.LevelStorageAccess convertable_conversionsession, PrimaryLevelData iworlddataserver, ResourceKey<Level> resourcekey, LevelStem worlddimension, ChunkProgressListener worldloadlistener, boolean flag, long i, List<CustomSpawner> list, boolean flag1, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider) {
+    // ASWM START
+        this(null, minecraftserver, executor, convertable_conversionsession, iworlddataserver, resourcekey, worlddimension, worldloadlistener, flag, i, list, flag1, env, gen, biomeProvider);
+    }
+
+    public com.infernalsuite.aswm.world.SlimeWorldInstance slimeInstance;
+
+    public ServerLevel(com.infernalsuite.aswm.level.SlimeBootstrap bootstrap, MinecraftServer minecraftserver, Executor executor, LevelStorageSource.LevelStorageAccess convertable_conversionsession, PrimaryLevelData iworlddataserver, ResourceKey<Level> resourcekey, LevelStem worlddimension, ChunkProgressListener worldloadlistener, boolean flag, long i, List<CustomSpawner> list, boolean flag1, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider) {
+    // ASWM END
         // Holder holder = worlddimension.type(); // CraftBukkit - decompile error
         // Objects.requireNonNull(minecraftserver); // CraftBukkit - decompile error
         super(iworlddataserver, resourcekey, worlddimension.type(), minecraftserver::getProfiler, false, flag, i, minecraftserver.getMaxChainedNeighborUpdates(), gen, biomeProvider, env, spigotConfig -> minecraftserver.paperConfigurations.createWorldConfig(io.papermc.paper.configuration.PaperConfigurations.createWorldContextMap(convertable_conversionsession.levelDirectory.path(), iworlddataserver.getLevelName(), resourcekey.location(), spigotConfig)), executor); // Paper - Async-Anti-Xray - Pass executor
@@ -563,6 +566,12 @@ public class ServerLevel extends Level implements WorldGenLevel {
             chunkgenerator = new org.bukkit.craftbukkit.generator.CustomChunkGenerator(this, chunkgenerator, gen);
         }
         // CraftBukkit end
+        // ASWM START
+        ChunkGenerator result = this.getGenerator();
+        if (result != null) {
+            chunkgenerator = result;
+        }
+        // ASWM END
         boolean flag2 = minecraftserver.forceSynchronousWrites();
         DataFixer datafixer = minecraftserver.getFixerUpper();
         this.entityStorage = new EntityRegionFileStorage(convertable_conversionsession.getDimensionPath(resourcekey).resolve("entities"), flag2); // Paper - rewrite chunk system  //EntityPersistentStorage<Entity> entitypersistentstorage = new EntityStorage(this, convertable_conversionsession.getDimensionPath(resourcekey).resolve("entities"), datafixer, flag2, minecraftserver);
@@ -609,6 +618,12 @@ public class ServerLevel extends Level implements WorldGenLevel {
         this.entityLookup = new io.papermc.paper.chunk.system.entity.EntityLookup(this, new EntityCallbacks()); // Paper - rewrite chunk system
     }
 
+    // ASWM START
+    public ChunkGenerator getGenerator() {
+        return null;
+    }
+    // ASWM END
+
     public void setWeatherParameters(int clearDuration, int rainDuration, boolean raining, boolean thundering) {
         this.serverLevelData.setClearWeatherTime(clearDuration);
         this.serverLevelData.setRainTime(rainDuration);
diff --git a/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java b/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
index 5049e969e06f4cc1826378249548064042c28410..f5234420363afa89449d61cb78e670ec6a3fdbd0 100644
--- a/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
+++ b/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
@@ -406,6 +406,16 @@ public class LevelStorageSource {
         // CraftBukkit start
         public final ResourceKey<LevelStem> dimensionType;
 
+//        // ASWM START
+//        public LevelStorageAccess() throws IOException {
+//            this.dimensionType = dimensionType;
+//            // CraftBukkit end
+//            this.levelId = s;
+//            this.levelDirectory = new LevelStorageSource.LevelDirectory(LevelStorageSource.this.baseDir.resolve(s));
+//            this.lock = DirectoryLock.create(this.levelDirectory.path());
+//        }
+//        // ASWM END
+
         public LevelStorageAccess(String s, ResourceKey<LevelStem> dimensionType) throws IOException {
             this.dimensionType = dimensionType;
             // CraftBukkit end
diff --git a/src/main/resources/META-INF/services/com.infernalsuite.aswm.SlimeNMSBridge b/src/main/resources/META-INF/services/com.infernalsuite.aswm.SlimeNMSBridge
new file mode 100644
index 0000000000000000000000000000000000000000..916b4d2edba2f2a8a0fc1fdb6ab6a57e2a16f938
--- /dev/null
+++ b/src/main/resources/META-INF/services/com.infernalsuite.aswm.SlimeNMSBridge
@@ -0,0 +1 @@
+com.infernalsuite.aswm.SlimeNMSBridgeImpl
